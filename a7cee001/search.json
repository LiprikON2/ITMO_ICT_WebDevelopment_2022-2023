[
  {
    "objectID": "students/k33401/Reingeverts_Vadim/Lr1/Web Dev - Лабораторная 1 - K33401 - Рейнгеверц В.А..html",
    "href": "students/k33401/Reingeverts_Vadim/Lr1/Web Dev - Лабораторная 1 - K33401 - Рейнгеверц В.А..html",
    "title": "Web-Development",
    "section": "",
    "text": "Реализовать клиентскую и серверную часть приложения. Клиент отсылает серверу сообщение «Hello, server». Сообщение должно отразиться на стороне сервера. Сервер в ответ отсылает клиенту сообщение «Hello, client». Сообщение должно отобразиться у клиента.\n\nОбязательно использовать библиотеку socket\nРеализовать с помощью протокола UDP\n\nПолезные ссылки: - https://habr.com/ru/post/149077/ - https://andreymal.org/socket3/ - https://docs.python.org/3.6/howto/sockets.html - https://docs.python.org/3.6/library/socket.html - https://www.youtube.com/watch?v=Lbfe3-v7yE0\n\n\n\n\n\n\n# %load \"Task 1/server.py\"\nimport socket\n\n\n# UDP\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# Ensures that port is always ready to be used again\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsock.bind(('localhost', 12346))\n\n# Makes keyboard interrupt possible at all times\nsock.settimeout(1.0)\n\nprint(\n    f\"Started server at udp://{sock.getsockname()[0]}:{sock.getsockname()[1]}\")\n\nwhile True:\n    try:\n        connection, client_address = None, None\n        try:\n            connection, client_address = sock.recvfrom(2048)\n        # Handle timeout\n        except IOError:\n            continue\n\n        data = connection.decode('utf-8')\n        print('Recived:', data)\n\n        sock.sendto(b\"Hello, client\", client_address)\n\n    except KeyboardInterrupt:\n        print(\"Stopping server...\")\n        if connection:\n            connection.close()\n        break\nsock.close()\n\n\n\n\nТак как Jupyter не хочет запускать cells в параллели, клиент запускается через командную строку:\npython \"./students/k33401/Reingeverts_Vadim/Lr1/Task 1/client.py\"\n\n# %load \"Task 1/client.py\"\nimport socket\n\n# UDP\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.connect(('localhost', 12346))\n\nsock.send(b\"Hello, server\")\n\ntry:\n    connection = sock.recv(2048)\n    data = connection.decode('utf-8')\n    print('Recived:', data)\nexcept ConnectionResetError:\n    print(\"Could not connect to the server\")\n\nsock.close()\n\n\n\n\n\n\n\n\nРеализовать клиентскую и серверную часть приложения. Клиент запрашивает у сервера выполнение математической операции, параметры, которые вводятся с клавиатуры. Сервер обрабатывает полученные данные и возвращает результат клиенту. Варианты:\n\nТеорема Пифагора\nРешение квадратного уравнения.\nПоиск площади трапеции.\nПоиск площади параллелограмма.\n\nВариант выбирается в соответствии с порядковым номером в журнале. Пятый студент получает вариант 1 и т.д.\n\nОбязательно использовать библиотеку socket\nРеализовать с помощью протокола TCP\n\n\n\n\n\n\n\n# %load \"Task 2/server.py\"\nimport socket\nfrom math import sqrt\n\n\ndef calc_pythagorean_equation(solveFor, x, y):\n    solution = None\n    x = float(x)\n    y = float(y)\n    \n    if solveFor == \"a\":\n        solution = sqrt(y**2 - x**2)\n    elif solveFor == \"b\":\n        solution = sqrt(y**2 - x**2)\n    else:\n        solution = sqrt(x**2 + y**2)\n    return solution\n\n\n# TCP\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# Ensures that port is always ready to be used again\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsock.bind(('localhost', 12346))\n\n\n# Makes keyboard interrupt possible at all times\nsock.settimeout(1.0)\nsock.listen(10)\n\nprint(\n    f\"Started server at tcp://{sock.getsockname()[0]}:{sock.getsockname()[1]}\")\n\nwhile True:\n    try:\n        connection, client_address = None, None\n        try:\n            connection, client_address = sock.accept()\n        # Handle timeout\n        except IOError:\n            continue\n        data = connection.recv(2048)\n        data = data.decode('utf-8')\n        print('Recived:\\n' + data)\n\n        solveFor, x, y, _ = data.split(\"\\n\")\n        solution = calc_pythagorean_equation(solveFor, x, y)\n\n        print(\"Sending response:\", solution)\n        connection.send(str(solution).encode('utf-8'))\n\n    except KeyboardInterrupt:\n        print(\"Stopping server...\")\n        if connection:\n            connection.close()\n        break\nsock.close()\n\n\n\n\nТак как Jupyter не хочет запускать cells в параллели, клиент запускается через командную строку:\npython \"./students/k33401/Reingeverts_Vadim/Lr1/Task 2/client.py\"\n\n# %load \"Task 2/client.py\"\nimport socket\n\n\ndef get_decimal_input(decimalName):\n    decimalNum = None\n    while True:\n        try:\n            decimalNum = float(input(f\"Enter value for {decimalName}: \"))\n        except ValueError:\n            print(\"Not a number.\")\n            continue\n        if decimalNum < 0:\n            print(f\"{decimalName} must be a positive number.\")\n            continue\n        else:\n            break\n    return decimalNum\n\n\n# TCP\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntry:\n    sock.connect(('localhost', 12346))\n\n    print(\"\\nPythagorean theorem solver.\")\n    print(\"\"\"\n        +\n        |\\\\\n        | \\\\ C\n      A |  \\\\\n        |   \\\\\n        +----+\n           B\n    \"\"\")\n    message = \"\"\n    option1 = \"\"\n    while True:\n        option1 = input(\"Choose to solve for (A, B or C): \").lower()\n        if option1 not in ('a', 'b', 'c'):\n            print(\"Not an appropriate choice.\")\n        else:\n            message += option1 + \"\\n\"\n            break\n    if (option1 == \"a\"):\n        b = get_decimal_input(\"B\")\n        c = get_decimal_input(\"C\")\n\n        message += str(b) + \"\\n\"\n        message += str(c) + \"\\n\"\n\n    elif (option1 == \"b\"):\n        a = get_decimal_input(\"A\")\n        c = get_decimal_input(\"C\")\n\n        message += str(a) + \"\\n\"\n        message += str(c) + \"\\n\"\n    else:\n        a = get_decimal_input(\"A\")\n        b = get_decimal_input(\"B\")\n\n        message += str(a) + \"\\n\"\n        message += str(b) + \"\\n\"\n\n    sock.send(message.encode(\"utf-8\"))\n    connection = sock.recv(2048)\n    data = connection.decode('utf-8')\n\n    print(f'\\nSolution for {option1.upper()} is:', data)\nexcept ConnectionRefusedError:\n    print(\"Could not connect to the server\")\n\n\nsock.close()\n\n\n\n\n\n\n\n\nРеализовать серверную часть приложения. Клиент подключается к серверу. В ответ клиент получает http-сообщение, содержащее html-страницу, которую сервер подгружает из файла index.html.\nПолезные ссылки: - http://zetcode.com/python/socket/ - Обязательно использовать библиотеку socket\n\n\n\n\n\n\n# %load \"Task 3/server.py\"\nimport socket\nfrom os import path\nfrom pathlib import Path\nimport webbrowser\n\n# Makes consistent path to work directory in case of\n# 1. Running .py file directly `python server.py`\n# 2. Running .py file from another directory `python ./someComplicatedPath/server.py`\n# 3. Running cell from .ipynb notebook\n\ncurr_dirname = None\nipynb_path = \"./Task 3\"\nif \"__file__\" in globals():\n    dirname = path.dirname(__file__)\nelse:\n    dirname = path.abspath(\"\") + ipynb_path\n\nindex_file = Path(dirname) / 'index.html'\n# TCP\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# Ensures that port is always ready to be used again\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsock.bind(('localhost', 0))\n\n# Makes keyboard interrupt possible at all times\nsock.settimeout(1.0)\nsock.listen(10)\n\nurl = f'http://{sock.getsockname()[0]}:{sock.getsockname()[1]}'\nprint(\n    f\"Started server at {url}\")\nwebbrowser.open(url)\n\nwhile True:\n    try:\n        connection, client_address = None, None\n        try:\n            connection, client_address = sock.accept()\n        # Handle timeout\n        except IOError:\n            continue\n\n        print(\"Incoming connection from:\", client_address)\n\n        response_type = \"HTTP/1.1 200 OK\\n\"\n        headers = \"Content-Type: text/html; charset=utf-8\\n\\n\"\n        \n        body = None\n        with open(index_file, 'r', encoding=\"utf-8\") as file:\n            body = file.read()\n            \n        response = response_type + headers + body\n        connection.sendall(response.encode('utf-8'))\n\n    except KeyboardInterrupt:\n        print(\"Stopping server...\")\n        if connection:\n            connection.close()\n        break\nsock.close()\n\n\n\n\n\n\n\n\nРеализовать двухпользовательский или многопользовательский чат. Реализация многопользовательского часа позволяет получить максимальное количество баллов. Обязательно использовать библиотеку Полезные ссылки: - https://docs.python.org/3/library/threading.html - https://webdevblog.ru/vvedenie-v-potoki-v-python/\n\n\nРеализовать с помощью протокола TCP – 100% баллов, с помощью UDP – 80%.\nОбязательно использовать библиотеку threading.\nДля реализации с помощью UDP, thearding использовать для получения сообщений у клиента.\nДля применения с TCP необходимо запускать клиентские подключения И прием и отправку сообщений всем юзерам на сервере в потоках. Не забудьте сохранять юзеров, чтобы потом отправлять им сообщения.\n\n\n\n\n\n\n\n# %load \"Task 4/server.py\"\nimport socket\nimport threading\nimport json\nfrom threading import Thread\n\n# ref: https://stackoverflow.com/a/43936317\n\n\nclass SocketServer(socket.socket):\n    clients = []\n\n    def __init__(self, host='localhost', port=12344):\n        # TCP\n        socket.socket.__init__(self, socket.AF_INET, socket.SOCK_STREAM)\n        # Ensures that port is always ready to be used again\n        self.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        self.bind((host, port))\n        self.listen(10)\n        # Makes keyboard interrupt possible at all times\n        self.settimeout(1.0)\n\n    def run(self):\n        print(\n            f\"Started server at tcp://{self.getsockname()[0]}:{self.getsockname()[1]}\")\n        try:\n            self.accept_clients()\n        except KeyboardInterrupt:\n            pass\n        finally:\n            self.stop()\n\n    def stop(self):\n        print(\"Stopping server...\")\n        for client in self.clients:\n            client.close()\n        self.close()\n        print(\"Server has stopped.\")\n\n    def accept_clients(self):\n        while True:\n            try:\n                connection, client_address = self.accept()\n            # Handle timeout\n            except TimeoutError:\n                continue\n\n            # Adding client to clients list\n            self.clients.append(connection)\n            # Client Connected\n            self.on_open(connection)\n            # Receiving data from client\n            thread = Thread(target=self.recieve, args=(connection,))\n            thread.start()\n\n    def recieve(self, connection):\n        while True:\n            try:\n                data = connection.recv(2048)\n            # Handle timeout\n            except TimeoutError:\n                continue\n            except ConnectionAbortedError:\n                break\n            if data == b\"\":\n                break\n            # Message Received\n            self.on_message(connection, data)\n        # Removing client from clients list\n        self.clients.remove(connection)\n        # Client Disconnected\n        self.on_close(connection)\n        # Closing connection with client\n        connection.close()\n\n        print(\"Current clients:\", len(self.clients))\n        return\n\n    def broadcast(self, message):\n        # Sending message to all clients\n        for client in self.clients:\n            print(\"Sending client a message...\")\n            client.send(message)\n\n    def on_open(self, connection):\n        pass\n\n    def on_message(self, connection, message):\n        pass\n\n    def on_close(self, connection):\n        pass\n\n\nclass ChatServer(SocketServer):\n\n    def __init__(self):\n        SocketServer.__init__(self)\n\n    def on_message(self, connection, message):\n\n        msg_dict = json.loads(message)  # data loaded\n        msg_dict[\"id\"] = f\"{connection.getpeername()[0]}:{connection.getpeername()[1]}\"\n        print(\"Recived:\", msg_dict)\n        # Serialize dict\n        serialized = json.dumps(msg_dict).encode(\"utf-8\")\n\n        # Sending message to all clients\n        self.broadcast(serialized)\n\n    def on_open(self, connection):\n        print(\"Client Connected\")\n\n    def on_close(self, connection):\n        print(\"Client Disconnected\")\n\n\nif __name__ == \"__main__\":\n    server = ChatServer()\n    server.run()\n\n\n\n\nТак как Jupyter не хочет запускать cells в параллели, клиент запускается через командную строку:\npython \"./students/k33401/Reingeverts_Vadim/Lr1/Task 4/client.py\"\n\n# %load \"Task 4/client.py\"\nimport os\nimport socket\nfrom threading import Thread\nimport json\n\n\ndef destructure(dict):\n    return (t[1] for t in dict.items())\n\n\nclass ChatClient(socket.socket):\n    name = \"\"\n    id = \"\"\n    is_connected = False\n\n    def __init__(self):\n        # TCP\n        socket.socket.__init__(self, socket.AF_INET, socket.SOCK_STREAM)\n        # Ensures that port is always ready to be used again\n        self.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # Makes keyboard interrupt possible at all times\n        self.settimeout(0.1)\n\n        self.name = input(\"Create a nickname: \") or \"Anonymous\"\n\n    def client_connect(self, host='localhost', port=12344):\n        try:\n            self.connect((host, port))\n            self.id = f\"{self.getsockname()[0]}:{self.getsockname()[1]}\"\n            self.is_connected = True\n\n        except IOError:\n            print(\"Could not connect to the server.\")\n            self.client_disconnect()\n\n        self.talk_with_server()\n\n    def talk_with_server(self):\n\n        thread1 = Thread(target=self.client_send)\n        thread2 = Thread(target=self.client_receive)\n\n        thread1.start()\n        thread2.start()\n\n    def client_send(self):\n        while True:\n            try:\n                text = input(\"\")\n                print()\n\n                msg_dict = {\"name\": self.name, \"text\": text}\n\n                # Serialize dict\n                serialized = json.dumps(msg_dict).encode(\"utf-8\")\n                self.send(serialized)\n\n            except TimeoutError:\n                continue\n            except (EOFError, IOError, OSError):\n                break\n            except KeyboardInterrupt:\n                break\n        self.client_disconnect()\n\n    def client_receive(self):\n        while True:\n            try:\n                data = self.recv(2048)\n                # Deserialize dict\n                msg_dict = json.loads(data)\n                name, text, id = destructure(msg_dict)\n                local_name = \"You\" if id == self.id else name\n\n                print(f\"{local_name}: {text}\")\n\n            except TimeoutError:\n                continue\n            except (ConnectionResetError, ConnectionAbortedError):\n                print(\"\\nServer closed connection.\")\n                break\n            except OSError:\n                break\n            except KeyboardInterrupt:\n                break\n        self.client_disconnect()\n\n    def client_disconnect(self):\n        if (self.is_connected):\n            self.close()\n        self.is_connected = False\n        os._exit(0)\n\n\nif __name__ == \"__main__\":\n    client = ChatClient()\n    client.client_connect()\n\n\n\n\n\n\n\n\nНеобходимо написать простой web-сервер для обработки GET и POST http запросов средствами Python и библиотеки socket.\nБазовый класс для простейшей реализации web-сервера доступен Google Doc\nПодробный мануал по работе доступен iximiuz - Python Web Server\nЗадание: сделать сервер, который может: - Принять и записать информацию о дисциплине и оценке по дисциплине. - Отдать информацию обо всех оценах по дисциплине в виде html-страницы.\n\n\n\n\n\n\n# %load \"Task 5/server.py\"\nimport socket\nfrom os import path\nfrom pathlib import Path\nimport webbrowser\nimport sys\nfrom urllib.parse import urlparse, parse_qs\n\n\nclass MyHTTPServer:\n    # Параметры сервера\n\n    def __init__(self, host='localhost', port=0, name=\"My HTTP Server\"):\n        self.host = host\n        self.port = port\n        self.name = name\n        self.data = {}\n\n    def serve_forever(self):\n        # 1. Запуск сервера на сокете, обработка входящих соединений\n        # TCP\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        # Ensures that port is always ready to be used again\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind((self.host, self.port))\n\n        # Makes keyboard interrupt possible at all times\n        sock.settimeout(1.0)\n        sock.listen(10)\n\n        url = f'http://{sock.getsockname()[0]}:{sock.getsockname()[1]}'\n        print(\n            f\"Started server at {url}\")\n        webbrowser.open(url)\n\n        while True:\n            try:\n                connection = self.serve_client(sock)\n            # Handle timeout\n            except IOError:\n                continue\n\n            except KeyboardInterrupt:\n                print(\"Stopping server...\")\n                if connection:\n                    connection.close()\n                break\n\n        sock.close()\n\n    def serve_client(self, sock):\n        # 2. Обработка клиентского подключения\n        try:\n            connection, client_address = sock.accept()\n        # Handle timeout\n        except IOError:\n            raise IOError\n        print(\"Incoming connection from:\", client_address)\n\n        self.handle_request(connection)\n\n        return connection\n\n    def parse_request(self, connection):\n        # 3. функция для обработки заголовка http+запроса. Python, сокет\n        # предоставляет возможность создать вокруг него некоторую обертку,\n        # которая предоставляет file object интерфейс. Это дайте возможность\n        # построчно обработать запрос. Заголовок всегда - первая строка.\n        # Первую строку нужно разбить на 3 элемента  (метод + url + версия протокола).\n        # URL необходимо разбить на адрес и параметры (isu.ifmo.ru/pls/apex/f?p=2143,\n        # где isu.ifmo.ru/pls/apex/f, а p=2143 - параметр p со значением 2143)\n        method, path, protocol, body = self.parse_headers(connection)\n        href = path.split('?')[0]\n\n        if method == 'GET':\n            query_dict = parse_qs(urlparse(path).query)\n        elif method == 'POST':\n            query_dict = parse_qs(body)\n\n        return method, href, query_dict\n\n    def parse_headers(self, connection):\n        # 4. Функция для обработки headers. Необходимо прочитать все заголовки после\n        # первой строки до появления пустой строки и сохранить их в массив.\n        data = connection.recv(2048)\n        data = data.decode('utf-8')\n\n        method, path, protocol = data.split('\\n')[0].split(' ')\n        body = data.split('\\r\\n\\r\\n')[1]\n\n        return method, path, protocol, body\n\n    def handle_request(self, connection):\n        # 5. Функция для обработки url в соответствии с нужным методом. В случае\n        # данной работы, нужно будет создать набор условий, который обрабатывает GET\n        # или POST запрос. GET запрос должен возвращать данные. POST запрос должен\n        # записывать данные на основе переданных параметров.\n        method, href, query_dict = self.parse_request(connection)\n\n        if (method == \"GET\" and href == \"/\"):\n            pass\n        elif (method == \"POST\" and href == \"/add\"):\n            for key, value in query_dict.items():\n                if key not in self.data:\n                    self.data[key] = value\n                else:\n                    self.data[key].append(value[0])\n\n        self.send_response(connection)\n\n    def send_response(self, connection):\n        # 6. Функция для отправки ответа. Необходимо записать в соединение status line\n        # вида HTTP/1.1 <status_code> <reason>. Затем, построчно записать заголовки и\n        # пустую строку, обозначающую конец секции заголовков.\n        response_type = \"HTTP/1.1 200 OK\\n\"\n        headers = \"Content-Type: text/html; charset=utf-8\\n\\n\"\n\n        with open(index_file, 'r', encoding=\"utf-8\") as file:\n            body = file.read()\n        parsed_body = self.insert_template_variables(\n            body, {\"table\": generate_table(self.data)})\n\n        response = response_type + headers + parsed_body\n        connection.sendall(response.encode('utf-8'))\n\n    def insert_template_variables(self, body, variables={\"table\": \"hello\", \"wtf\": \"1\"}):\n        cursor = 0\n        while True:\n            index_start = body.find(\"{{\", cursor)\n            if (index_start != -1):\n                index_end = body.find(\"}}\", cursor)\n                if (index_end == -1):\n                    raise Exception(\n                        f\"Could not find closing brackets at {cursor}\")\n\n                var = body[index_start + 2:index_end].strip(' ')\n                cursor = index_end + 2\n\n                if var in variables:\n                    body = body[:index_start] + \\\n                        variables[var] + body[index_end + 2:]\n                    cursor = index_start + len(variables[var])\n\n            else:\n                break\n        return body\n\n\ndef generate_table(data={}):\n    table = \"\"\n    if (data):\n        table_headings = []\n        table_row_cells = []\n        for key, value in data.items():\n            table_headings.append(f'<th>{key.title()}</th>')\n            for cell in value:\n                table_row_cells.append(f'<td>{cell}</td>')\n\n        split_every = len(table_row_cells) // len(table_headings)\n        rows = [table_row_cells[i::split_every] for i in range(split_every)]\n\n        nl = '\\n'\n        table_rows = []\n        for row in rows:\n            table_row = \"<tr>\" + nl.join(row) + \"</tr>\"\n            table_rows.append(table_row)\n\n        table = f\"\"\"\n            <table>\n                <tr>\n                    {nl.join(table_headings)}\n                </tr>\n                {nl.join(table_rows)}\n            </table>\n        \"\"\"\n    return table\n\n\nif __name__ == '__main__':\n    # Makes consistent path to work directory in case of\n    # 1. Running .py file directly `python server.py`\n    # 2. Running .py file from another directory `python ./someComplicatedPath/server.py`\n    # 3. Running cell from .ipynb notebook\n    ipynb_path = \"./Task 5\"\n    if \"__file__\" in globals():\n        dirname = path.dirname(__file__)\n    else:\n        dirname = Path(path.abspath(\"\") + ipynb_path)\n    index_file = Path(dirname) / 'index.html'\n\n    serv = MyHTTPServer()\n\n    serv.serve_forever()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Web-Development",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites."
  }
]